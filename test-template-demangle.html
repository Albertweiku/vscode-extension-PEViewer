<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ¨¡æ¿å‡½æ•°åè§£ç æµ‹è¯•</title>
    <style>
        body { font-family: 'Consolas', monospace; padding: 20px; }
        .test { margin: 20px 0; padding: 15px; background: #f5f5f5; border-left: 4px solid #007acc; }
        .success { border-left-color: #4CAF50; }
        .error { border-left-color: #f44336; }
        .mangled { color: #d32f2f; font-weight: bold; }
        .demangled { color: #1976d2; font-weight: bold; }
    </style>
</head>
<body>
    <h1>ğŸ”§ æ¨¡æ¿å‡½æ•°åè§£ç æµ‹è¯•</h1>
    <div id="results"></div>

    <script>
        // å¤åˆ¶ä¿®å¤åçš„è§£ç å‡½æ•°
        function demangleMsvc(mangled) {
            try {
                let pos = 1;
                const str = mangled;

                function peek() {
                    return pos < str.length ? str[pos] : '';
                }

                function read() {
                    return pos < str.length ? str[pos++] : '';
                }

                function readSourceName() {
                    let name = '';
                    // å¤„ç†æ¨¡æ¿åç§°: ?$name@template_args@
                    if (peek() === '?' && pos + 1 < str.length && str[pos + 1] === '$') {
                        pos += 2; // è·³è¿‡ ?$
                        // è¯»å–æ¨¡æ¿åç§°
                        while (pos < str.length && str[pos] !== '@') {
                            name += str[pos++];
                        }
                        
                        // è¯»å–å¹¶ç®€åŒ–æ¨¡æ¿å‚æ•°
                        if (peek() === '@') {
                            pos++; // è·³è¿‡ @
                            let templateArgs = '';
                            let depth = 1;
                            const argStart = pos;
                            
                            while (pos < str.length && depth > 0) {
                                const ch = str[pos];
                                if (ch === '@') {
                                    // æ£€æŸ¥ä¸‹ä¸€ä¸ªå­—ç¬¦æ¥åˆ¤æ–­æ˜¯å¦ç»“æŸ
                                    if (pos + 1 < str.length && str[pos + 1] !== '$' && str[pos + 1] !== '?') {
                                        // è¿™æ˜¯æ¨¡æ¿å‚æ•°çš„ç»“æŸ
                                        depth--;
                                        if (depth === 0) {
                                            templateArgs = str.substring(argStart, pos);
                                            pos++; // è·³è¿‡ç»“æŸçš„ @
                                            break;
                                        }
                                    }
                                } else if (ch === '?' && pos + 1 < str.length && str[pos + 1] === '$') {
                                    // åµŒå¥—æ¨¡æ¿
                                    depth++;
                                }
                                pos++;
                            }
                            
                            // ç®€åŒ–æ¨¡æ¿å‚æ•°æ˜¾ç¤º
                            if (templateArgs) {
                                // MSVC æ¨¡æ¿å‚æ•°ç¼–ç è§„åˆ™ï¼š
                                // $0A@ = 0, $00@ = 1, $01@ = 2, etc.
                                // $H = int, $D = char, $N = bool, etc.
                                let simplifiedArgs = templateArgs;
                                
                                // æ•°å­—æ¨¡æ¿å‚æ•°
                                if (templateArgs.startsWith('$0')) {
                                    const numPart = templateArgs.substring(1);
                                    if (numPart === '0A') {
                                        simplifiedArgs = '0';
                                    } else if (numPart.match(/^0[0-9A-F]$/)) {
                                        // $00=1, $01=2, ... $09=10, $0A=0(å¾ªç¯), $0B=11, etc.
                                        const hexDigit = numPart[1];
                                        if (hexDigit >= '0' && hexDigit <= '9') {
                                            simplifiedArgs = String(parseInt(hexDigit, 10) + 1);
                                        } else {
                                            simplifiedArgs = String(parseInt(hexDigit, 16));
                                        }
                                    }
                                }
                                // ç±»å‹æ¨¡æ¿å‚æ•°ï¼ˆç®€åŒ–æ˜¾ç¤ºï¼‰
                                else if (templateArgs === 'H') {
                                    simplifiedArgs = 'int';
                                } else if (templateArgs === 'D') {
                                    simplifiedArgs = 'char';
                                } else if (templateArgs === '_N') {
                                    simplifiedArgs = 'bool';
                                }
                                
                                name += `<${simplifiedArgs}>`;
                            }
                        }
                        return name;
                    }
                    
                    // æ™®é€šåç§°
                    while (pos < str.length && str[pos] !== '@') {
                        name += str[pos++];
                    }
                    return name;
                }

                function readQualifiedName() {
                    const parts = [];
                    while (pos < str.length) {
                        if (peek() === '@') {
                            pos++;
                            if (peek() === '@') {
                                pos++;
                                break;
                            }
                            continue;
                        }
                        const part = readSourceName();
                        if (part) {
                            parts.push(part);
                        }
                    }
                    return parts.reverse().join('::');
                }

                const specialNames = {
                    '0': 'constructor',
                    '1': 'destructor',
                    '2': 'operator new',
                    '3': 'operator delete',
                    '4': 'operator=',
                };

                // æ£€æŸ¥ç‰¹æ®Šåç§°
                if (peek() === '?') {
                    pos++;
                    const opCode = read();
                    let opName = specialNames[opCode] || `operator${opCode}`;
                    
                    const className = readQualifiedName();
                    
                    if (opName === 'constructor') {
                        const simpleName = className.split('::').pop() || className;
                        return `${className}::${simpleName}()`;
                    } else if (opName === 'destructor') {
                        const simpleName = className.split('::').pop() || className;
                        return `${className}::~${simpleName}()`;
                    }
                    return `${className}::${opName}`;
                }

                // æ™®é€šå‡½æ•°æˆ–æˆå‘˜å‡½æ•°
                const funcName = readSourceName();
                const scope = readQualifiedName();
                
                if (scope) {
                    return `${scope}::${funcName}()`;
                }
                return funcName ? `${funcName}()` : mangled;

            } catch (e) {
                console.error('Decode error:', e);
                return mangled;
            }
        }

        // æµ‹è¯•ç”¨ä¾‹
        const tests = [
            {
                mangled: '??0?$_SpinWait@$0A@@details@Concurrency@@QEAA@P6AXXZ@Z',
                expected: 'Concurrency::details::_SpinWait<0>::_SpinWait()',
                description: 'æ¨¡æ¿ç±»æ„é€ å‡½æ•° _SpinWait<0> (å‚æ•°=$0A@è¡¨ç¤º0)'
            },
            {
                mangled: '??0?$_SpinWait@$00@details@Concurrency@@QEAA@P6AXXZ@Z',
                expected: 'Concurrency::details::_SpinWait<1>::_SpinWait()',
                description: 'æ¨¡æ¿ç±»æ„é€ å‡½æ•° _SpinWait<1> (å‚æ•°=$00@è¡¨ç¤º1)'
            },
            {
                mangled: '??0?$_SpinWait@$01@details@Concurrency@@QEAA@P6AXXZ@Z',
                expected: 'Concurrency::details::_SpinWait<2>::_SpinWait()',
                description: 'æ¨¡æ¿ç±»æ„é€ å‡½æ•° _SpinWait<2> (å‚æ•°=$01@è¡¨ç¤º2)'
            },
            {
                mangled: '??0?$vector@H@std@@QEAA@XZ',
                expected: 'std::vector<int>::vector()',
                description: 'æ¨¡æ¿ç±»æ„é€ å‡½æ•° vector<int> (å‚æ•°=Hè¡¨ç¤ºint)'
            },
            {
                mangled: '??0?$basic_string@D@std@@QEAA@XZ',
                expected: 'std::basic_string<char>::basic_string()',
                description: 'æ¨¡æ¿ç±»æ„é€ å‡½æ•° basic_string<char> (å‚æ•°=Dè¡¨ç¤ºchar)'
            },
            {
                mangled: '??1?$vector@H@std@@QEAA@XZ',
                expected: 'std::vector<int>::~vector()',
                description: 'æ¨¡æ¿ç±»ææ„å‡½æ•° vector<int>'
            },
            {
                mangled: '??0MyClass@@QEAA@XZ',
                expected: 'MyClass::MyClass()',
                description: 'æ™®é€šç±»æ„é€ å‡½æ•°'
            },
            {
                mangled: '?func@MyClass@@QEAAXXZ',
                expected: 'MyClass::func()',
                description: 'æ™®é€šæˆå‘˜å‡½æ•°'
            }
        ];

        const resultsDiv = document.getElementById('results');
        let passCount = 0;

        tests.forEach((test, index) => {
            const result = demangleMsvc(test.mangled);
            const pass = result === test.expected;
            if (pass) passCount++;

            const div = document.createElement('div');
            div.className = `test ${pass ? 'success' : 'error'}`;
            div.innerHTML = `
                <h3>${pass ? 'âœ…' : 'âŒ'} æµ‹è¯• ${index + 1}: ${test.description}</h3>
                <div><strong>åŸå§‹ç¬¦å·:</strong> <span class="mangled">${test.mangled}</span></div>
                <div><strong>æœŸæœ›ç»“æœ:</strong> <span class="demangled">${test.expected}</span></div>
                <div><strong>å®é™…ç»“æœ:</strong> <span class="demangled">${result}</span></div>
                ${!pass ? '<div style="color: #f44336; margin-top: 5px;"><strong>âš ï¸ ä¸åŒ¹é…!</strong></div>' : ''}
            `;
            resultsDiv.appendChild(div);
        });

        const summary = document.createElement('div');
        summary.style.cssText = 'margin-top: 30px; padding: 20px; background: #e8f5e9; border-radius: 8px;';
        summary.innerHTML = `
            <h2>ğŸ“Š æµ‹è¯•æ€»ç»“</h2>
            <p><strong>é€šè¿‡: ${passCount}/${tests.length}</strong></p>
            <p><strong>æˆåŠŸç‡: ${((passCount / tests.length) * 100).toFixed(1)}%</strong></p>
        `;
        resultsDiv.appendChild(summary);
    </script>
</body>
</html>
